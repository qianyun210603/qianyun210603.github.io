---
title: 【C++知识库】关于std::function的开销
date: 2024-07-01T18:26:49+08:00
toc: true
tags: 
categories: 
- Programming
- C++
---

在 C++ 中使用 `std::function` 相比于使用函数指针或直接函数调用会引入一定的运行时成本。这个成本主要是由于 `std::function` 使用的类型擦除机制，使其能够存储、复制和调用任何与其签名匹配的可调用目标（函数、lambda 表达式、bind 表达式或其他函数对象）。以下是导致其运行时成本的关键因素：

1. 间接性：`std::function` 涉及一个额外的间接层级。当你调用一个 `std::function` 时，它内部通过指向虚函数表（vtable）的指针调用存储的可调用对象。这种间接性可以阻止某些编译器优化，如内联，这些优化对于直接函数调用或甚至是函数指针来说更可行。
2. 堆分配：对于超出小对象优化（SOO）阈值（这是实现定义的）的可调用对象，`std::function` 可能会执行堆分配。这可能引入动态内存分配/释放的开销，并可能导致堆碎片化。然而，对于小对象，`std::function` 通常使用一种优化来在栈上存储对象，避免了堆分配。
3. 类型擦除开销：使 `std::function` 能够存储任何匹配签名的可调用类型的类型擦除机制也引入了开销。这是因为它必须维护对各种可调用类型的统一接口，这涉及到存储额外的元数据，并可能执行动态类型检查。
4. 复制/移动操作：复制或移动 `std::function` 对象可能比简单的函数指针更昂贵，特别是如果存储的可调用对象很大或需要堆分配。成本取决于存储的可调用对象的复制/移动操作的复杂性。

尽管存在这些开销，`std::function` 在许多场景中都是非常通用且有用的，例如当你需要存储回调、实现信号-槽机制或处理高阶函数时。它提供的灵活性和类型安全性通常可以证明这些运行时成本是合理的。然而，对于性能关键的代码路径，每个周期都很重要，考虑使用直接函数调用、函数指针或模板基础解决方案可能是更高效的选择，编译器可以对其进行更有效的优化。



## 参考资料
> - Github Copilot
